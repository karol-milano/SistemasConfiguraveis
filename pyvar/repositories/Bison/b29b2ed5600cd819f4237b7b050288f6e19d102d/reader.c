@@ -36,13 +36,11 @@
 #include "conflicts.h"
 #include "muscle_tab.h"
 
-/* Number of slots allocated (but not necessarily used yet) in `rline'  */
-static int rline_allocated;
-
 typedef struct symbol_list
 {
   struct symbol_list *next;
   bucket *sym;
+  int line;
   bucket *ruleprec;
 }
 symbol_list;
@@ -66,6 +64,19 @@ static int lastprec;
 
 static bucket *errtoken;
 static bucket *undeftoken;
+
+
+symbol_list *
+symbol_list_new (bucket *sym)
+{
+  symbol_list *res = XMALLOC (symbol_list, 1);
+  res->next = NULL;
+  res->sym = sym;
+  res->line = lineno;
+  res->ruleprec = NULL;
+  return res;
+}
+
 
 
 /*===================\
@@ -123,7 +134,7 @@ read_signed_integer (FILE *stream)
 `--------------------------------------------------------------*/
 
 static char *
-get_type_name (int n, symbol_list * rule)
+get_type_name (int n, symbol_list *rule)
 {
   int i;
   symbol_list *rp;
@@ -568,7 +579,8 @@ parse_token_decl (symbol_class what_is, symbol_class what_is_not)
       else
 	{
 	  complain (_("`%s' is invalid in %s"),
-		    token_buffer, (what_is == token_sym) ? "%token" : "%nterm");
+		    token_buffer,
+		    (what_is == token_sym) ? "%token" : "%nterm");
 	  skip_to_char ('%');
 	}
     }
@@ -1393,8 +1405,7 @@ readgram (void)
 	  nrules++;
 	  nitems++;
 
-	  p = XCALLOC (symbol_list, 1);
-	  p->sym = lhs;
+	  p = symbol_list_new (lhs);
 
 	  crule1 = p1;
 	  if (p1)
@@ -1456,27 +1467,25 @@ readgram (void)
 	         non-terminal.  */
 	      if (action_flag)
 		{
-		  bucket *sdummy;
-
 		  /* Since the action was written out with this rule's
 		     number, we must give the new rule this number by
 		     inserting the new rule before it.  */
 
 		  /* Make a dummy nonterminal, a gensym.  */
-		  sdummy = gensym ();
+		  bucket *sdummy = gensym ();
 
 		  /* Make a new rule, whose body is empty,
 		     before the current one, so that the action
 		     just read can belong to it.  */
 		  nrules++;
 		  nitems++;
-		  p = XCALLOC (symbol_list, 1);
+		  p = symbol_list_new (sdummy);
 		  if (crule1)
 		    crule1->next = p;
 		  else
 		    grammar = p;
-		  p->sym = sdummy;
-		  crule1 = XCALLOC (symbol_list, 1);
+		  /* End of the rule. */
+		  crule1 = symbol_list_new (NULL);
 		  crule1->next = crule;
 
 		  p->next = crule1;
@@ -1484,8 +1493,7 @@ readgram (void)
 		  /* Insert the dummy generated by that rule into this
 		     rule.  */
 		  nitems++;
-		  p = XCALLOC (symbol_list, 1);
-		  p->sym = sdummy;
+		  p = symbol_list_new (sdummy);
 		  p1->next = p;
 		  p1 = p;
 
@@ -1495,8 +1503,7 @@ readgram (void)
 	      if (t == tok_identifier)
 		{
 		  nitems++;
-		  p = XCALLOC (symbol_list, 1);
-		  p->sym = symval;
+		  p = symbol_list_new (symval);
 		  p1->next = p;
 		  p1 = p;
 		}
@@ -1510,7 +1517,7 @@ readgram (void)
 	    }			/* end of  read rhs of rule */
 
 	  /* Put an empty link in the list to mark the end of this rule  */
-	  p = XCALLOC (symbol_list, 1);
+	  p = symbol_list_new (NULL);
 	  p1->next = p;
 	  p1 = p;
 
@@ -1903,8 +1910,6 @@ packgram (void)
   int ruleno;
   symbol_list *p;
 
-  bucket *ruleprec;
-
   ritem = XCALLOC (short, nitems + 1);
   rule_table = XCALLOC (rule_t, nrules) - 1;
 
@@ -1914,10 +1919,10 @@ packgram (void)
   p = grammar;
   while (p)
     {
+      bucket *ruleprec = p->ruleprec;
       rule_table[ruleno].lhs = p->sym->value;
       rule_table[ruleno].rhs = itemno;
-      rule_table[ruleno].line = p->sym->line;
-      ruleprec = p->ruleprec;
+      rule_table[ruleno].line = p->line;
 
       p = p->next;
       while (p && p->sym)
