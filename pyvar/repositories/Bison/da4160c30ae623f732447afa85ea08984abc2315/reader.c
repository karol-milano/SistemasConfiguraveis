@@ -1089,18 +1089,49 @@ grammar_symbol_append (symbol_t *s)
   grammar_end = p;
 }
 
+/* The rule currently being defined, and the previous rule.  Point to
+   the first symbol of each list: their lhs.  */
+symbol_list *current_rule = NULL;
+symbol_list *previous_rule = NULL;
+
+
+/* Create a new rule for LHS in to the GRAMMAR. */
+
+static void
+grammar_rule_begin (symbol_t *lhs)
+{
+  if (!start_flag)
+    {
+      startsymbol = lhs;
+      start_flag = 1;
+    }
+
+  /* Start a new rule and record its lhs.  */
+  ++nrules;
+  ++nritems;
+
+  previous_rule = grammar_end;
+  grammar_symbol_append (lhs);
+  current_rule = grammar_end;
+
+  /* Mark the rule's lhs as a nonterminal if not already so.  */
+
+  if (lhs->class == unknown_sym)
+    {
+      lhs->class = nterm_sym;
+      lhs->number = nvars;
+      ++nvars;
+    }
+  else if (lhs->class == token_sym)
+    complain (_("rule given for %s, which is a token"), lhs->tag);
+}
+
 static void
 readgram (void)
 {
   token_t t;
   symbol_t *lhs = NULL;
 
-  /* Points to first symbol_list of current rule. its symbol is the
-     lhs of the rule.  */
-  symbol_list *crule = NULL;
-  /* Points to the symbol_list preceding crule.  */
-  symbol_list *crule1 = NULL;
-
   t = lex ();
 
   while (t != tok_two_percents && t != tok_eof)
@@ -1116,12 +1147,6 @@ readgram (void)
 	  {
 	    lhs = symval;
 
-	    if (!start_flag)
-	      {
-		startsymbol = lhs;
-		start_flag = 1;
-	      }
-
 	    t = lex ();
 	    if (t != tok_colon)
 	      {
@@ -1129,32 +1154,13 @@ readgram (void)
 		unlex (t);
 	      }
 	  }
-
 	if (nrules == 0 && t == tok_bar)
 	  {
 	    complain (_("grammar starts with vertical bar"));
 	    lhs = symval;	/* BOGUS: use a random symval */
 	  }
-	/* start a new rule and record its lhs.  */
-
-	++nrules;
-	++nritems;
-
-	crule1 = grammar_end;
-	grammar_symbol_append (lhs);
-	crule = grammar_end;
-
-	/* mark the rule's lhs as a nonterminal if not already so.  */
-
-	if (lhs->class == unknown_sym)
-	  {
-	    lhs->class = nterm_sym;
-	    lhs->number = nvars;
-	    ++nvars;
-	  }
-	else if (lhs->class == token_sym)
-	  complain (_("rule given for %s, which is a token"), lhs->tag);
 
+	grammar_rule_begin (lhs);
 	/* read the rhs of the rule.  */
 
 	for (;;)
@@ -1163,7 +1169,7 @@ readgram (void)
 	    if (t == tok_prec)
 	      {
 		t = lex ();
-		crule->ruleprec = symval;
+		current_rule->ruleprec = symval;
 		t = lex ();
 	      }
 
@@ -1212,21 +1218,21 @@ readgram (void)
 		++nrules;
 		++nritems;
 		/* Attach its lineno to that of the host rule. */
-		p->line = crule->line;
+		p->line = current_rule->line;
 		/* Move the action from the host rule to this one. */
-		p->action = crule->action;
-		p->action_line = crule->action_line;
-		crule->action = NULL;
+		p->action = current_rule->action;
+		p->action_line = current_rule->action_line;
+		current_rule->action = NULL;
 
-		if (crule1)
-		  crule1->next = p;
+		if (previous_rule)
+		  previous_rule->next = p;
 		else
 		  grammar = p;
 		/* End of the rule. */
-		crule1 = symbol_list_new (NULL);
-		crule1->next = crule;
+		previous_rule = symbol_list_new (NULL);
+		previous_rule->next = current_rule;
 
-		p->next = crule1;
+		p->next = previous_rule;
 
 		/* Insert the dummy generated by that rule into this
 		   rule.  */
@@ -1242,7 +1248,7 @@ readgram (void)
 	      }
 	    else		/* handle an action.  */
 	      {
-		parse_action (crule, rulelength);
+		parse_action (current_rule, rulelength);
 		action_flag = 1;
 		++xactions;	/* JF */
 	      }
@@ -1256,7 +1262,7 @@ readgram (void)
 	  {
 	    complain (_("two @prec's in a row"));
 	    t = lex ();
-	    crule->ruleprec = symval;
+	    current_rule->ruleprec = symval;
 	    t = lex ();
 	  }
 
@@ -1265,7 +1271,7 @@ readgram (void)
 	    /* This case never occurs -wjh */
 	    if (action_flag)
 	      complain (_("two actions at end of one rule"));
-	    parse_action (crule, rulelength);
+	    parse_action (current_rule, rulelength);
 	    action_flag = 1;
 	    ++xactions;	/* -wjh */
 	    t = lex ();
