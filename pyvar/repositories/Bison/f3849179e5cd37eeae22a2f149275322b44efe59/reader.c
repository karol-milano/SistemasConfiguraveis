@@ -326,7 +326,7 @@ get_type_name (int n, symbol_list *rule)
 	  complain (_("invalid $ value"));
 	  return NULL;
 	}
-      i++;
+      ++i;
     }
 
   return rp->sym->type_name;
@@ -369,7 +369,7 @@ copy_string2 (FILE *fin, struct obstack *oout, int match, int store)
 	  obstack_1grow (oout, c);
 
 	  if (c == '\n')
-	    lineno++;
+	    ++lineno;
 	}
 
       c = getc (fin);
@@ -452,7 +452,7 @@ copy_comment (FILE *fin, struct obstack *oout)
 	}
       else if (c == '\n')
 	{
-	  lineno++;
+	  ++lineno;
 	  obstack_1grow (oout, c);
 	  if (cplus_comment)
 	    ended = 1;
@@ -614,7 +614,7 @@ copy_definition (void)
 	{
 	case '\n':
 	  obstack_1grow (&attrs_obstack, c);
-	  lineno++;
+	  ++lineno;
 	  break;
 
 	case '%':
@@ -826,7 +826,8 @@ parse_assoc_decl (associativity assoc)
   char *name = NULL;
   int prev = 0;
 
-  lastprec++;			/* Assign a new precedence level, never 0.  */
+  /* Assign a new precedence level, never 0.  */
+  ++lastprec;
 
   for (;;)
     {
@@ -931,7 +932,7 @@ parse_union_decl (void)
       switch (c)
 	{
 	case '\n':
-	  lineno++;
+	  ++lineno;
 	  break;
 
 	case '/':
@@ -939,7 +940,7 @@ parse_union_decl (void)
 	  break;
 
 	case '{':
-	  count++;
+	  ++count;
 	  break;
 
 	case '}':
@@ -1276,12 +1277,12 @@ parse_braces (symbol_list *rule, int stack_offset)
 	  {
 	  case '\n':
 	    obstack_1grow (&action_obstack, c);
-	    lineno++;
+	    ++lineno;
 	    break;
 
 	  case '{':
 	    obstack_1grow (&action_obstack, c);
-	    count++;
+	    ++count;
 	    break;
 
 	  case '\'':
@@ -1431,8 +1432,8 @@ readgram (void)
 	  }
 	/* start a new rule and record its lhs.  */
 
-	nrules++;
-	nitems++;
+	++nrules;
+	++nitems;
 
 	p = symbol_list_new (lhs);
 
@@ -1451,7 +1452,7 @@ readgram (void)
 	  {
 	    lhs->class = nterm_sym;
 	    lhs->number = nvars;
-	    nvars++;
+	    ++nvars;
 	  }
 	else if (lhs->class == token_sym)
 	  complain (_("rule given for %s, which is a token"), lhs->tag);
@@ -1509,8 +1510,8 @@ readgram (void)
 		/* Make a new rule, whose body is empty, before the
 		   current one, so that the action just read can
 		   belong to it.  */
-		nrules++;
-		nitems++;
+		++nrules;
+		++nitems;
 		p = symbol_list_new (sdummy);
 		/* Attach its lineno to that of the host rule. */
 		p->line = crule->line;
@@ -1531,7 +1532,7 @@ readgram (void)
 
 		/* Insert the dummy generated by that rule into this
 		   rule.  */
-		nitems++;
+		++nitems;
 		p = symbol_list_new (sdummy);
 		p1->next = p;
 		p1 = p;
@@ -1541,7 +1542,7 @@ readgram (void)
 
 	    if (t == tok_identifier)
 	      {
-		nitems++;
+		++nitems;
 		p = symbol_list_new (symval);
 		p1->next = p;
 		p1 = p;
@@ -1550,9 +1551,9 @@ readgram (void)
 	      {
 		parse_action (crule, rulelength);
 		action_flag = 1;
-		xactions++;	/* JF */
+		++xactions;	/* JF */
 	      }
-	    rulelength++;
+	    ++rulelength;
 	  }			/* end of  read rhs of rule */
 
 	/* Put an empty link in the list to mark the end of this rule  */
@@ -1584,7 +1585,7 @@ readgram (void)
 	      complain (_("two actions at end of one rule"));
 	    parse_action (crule, rulelength);
 	    action_flag = 1;
-	    xactions++;	/* -wjh */
+	    ++xactions;	/* -wjh */
 	    t = lex ();
 	  }
 	/* If $$ is being set in default way, report if any type
@@ -1785,7 +1786,7 @@ packgram (void)
 	  rules[ruleno].prec = ruleprec;
 	}
       ritem[itemno++] = -ruleno;
-      ruleno++;
+      ++ruleno;
 
       if (p)
 	p = p->next;
